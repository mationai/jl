// Generated by CoffeeScript 1.3.3
(function() {
  "Living code in documents\n\ngeneralises coding.js for multiple languages\nalso name-spaces it\n\ndependiences:\n  scheme: BiwaScheme\n  javascript: SandboxJS - https://github.com/TooTallNate/SandboxJS";

  var $create, $get, Codeblock, Context, DEBUG, Editor, HTMLContext, Id, JavascriptContext, LIB_CLASS, LanguageController, OutputWindow, RUNNING_CLASS, Scanner, Set, TwoWayDict, exports, hashContains, log, logEnd, logStart,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  LIB_CLASS = "livecode";

  RUNNING_CLASS = "running";

  DEBUG = false;

  exports = {};

  /*
  Helper functions --------------------------------------------------------------
  */


  if (DEBUG) {
    log = function() {
      return console.log.apply(console, arguments);
    };
    logStart = function() {
      return console.group.apply(console, arguments);
    };
    logEnd = function() {
      return console.groupEnd.apply(console, arguments);
    };
  } else {
    log = logStart = logEnd = function() {};
  }

  $create = function(tag) {
    return $(document.createElement(tag));
  };

  $get = function(node) {
    return $(node).get(0);
  };

  hashContains = function(hash, val) {
    return hash[val] !== void 0;
  };

  /*
  Helper classes ----------------------------------------------------------------
  */


  TwoWayDict = (function() {

    function TwoWayDict(hash) {
      var k, v;
      this.key_value = {};
      this.value_key = {};
      if (hash != null) {
        this.key_value = hash;
        for (k in hash) {
          v = hash[k];
          this.value_key[v] = k;
        }
      }
    }

    TwoWayDict.prototype.contains = function(v) {
      return hashContains(this.key_value, v) || hashContains(this.value_key, v);
    };

    TwoWayDict.prototype.assoc = function(k, v) {
      this.key_value[k] = v;
      return this.value_key[v] = k;
    };

    TwoWayDict.prototype.get = function(k) {
      var key, val;
      val = this.key_value[k];
      key = this.value_key[k];
      return val != null ? val : key;
    };

    return TwoWayDict;

  })();

  Set = (function() {

    function Set(array) {
      var o, _i, _len;
      this.dict = {};
      if (array != null) {
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          o = array[_i];
          this.add(o);
        }
      }
    }

    Set.prototype.add = function(obj) {
      return this.dict[obj] = true;
    };

    Set.prototype.remove = function(obj) {
      delete this.dict[obj];
      return obj;
    };

    Set.prototype.contains = function(obj) {
      return this.dict[obj] !== void 0;
    };

    return Set;

  })();

  Id = (function() {
    var uuid, uuid_counter;

    uuid_counter = 0;

    uuid = function() {
      uuid_counter = uuid_counter + 1;
      return "#" + uuid_counter;
    };

    function Id() {
      this.__id = uuid();
    }

    Id.prototype.toString = function() {
      return "" + this.constructor.name + "<" + this.__id + ">";
    };

    return Id;

  })();

  /*
  Language Contexts -------------------------------------------------------------
  
  a language environment with its own global scope
  must have one method: eval, which takes code as a string,
  and returns the result of evaluating that code in the context
    eval: returns any object suitable to append to the DOM.
          strings, DOM elemnts, numbers are OK
  */


  Context = (function(_super) {

    __extends(Context, _super);

    function Context() {
      return Context.__super__.constructor.apply(this, arguments);
    }

    Context.prototype["eval"] = function(code) {
      log('evaling code in context', this, code);
      return code;
    };

    Context.prototype.toString = function() {
      return "Context:" + (Context.__super__.toString.call(this));
    };

    return Context;

  })(Id);

  JavascriptContext = (function(_super) {

    __extends(JavascriptContext, _super);

    function JavascriptContext() {
      JavascriptContext.__super__.constructor.call(this);
      this.ctx = new Sandbox(true);
    }

    JavascriptContext.prototype["eval"] = function(code) {
      code = JavascriptContext.__super__["eval"].call(this, code);
      try {
        return JSON.stringify(this.ctx["eval"](code));
      } catch (err) {
        return err.toString();
      }
    };

    return JavascriptContext;

  })(Context);

  HTMLContext = (function(_super) {
    var iframe;

    __extends(HTMLContext, _super);

    function HTMLContext() {
      return HTMLContext.__super__.constructor.apply(this, arguments);
    }

    iframe = $('<iframe seamless></iframe>').css({
      width: '100%',
      height: '100%'
    });

    HTMLContext.prototype["eval"] = function(code) {
      var elem;
      elem = window.latest_frame = iframe.clone().load(function() {
        var doc;
        doc = this.contentDocument || this.contentWindow.document;
        doc.open();
        doc.write(code);
        doc.close();
        return $(this).height(doc.body.scrollHeight);
      });
      return elem;
    };

    return HTMLContext;

  })(Context);

  /*
  Module language exports -------------------------------------------------------
  
  To add support for a language, add an entry to exports.languages with
    name:     [String]   name of the language to pass to editors
    context:  [Context]  evaluation context class for this language
  */


  exports.languages = {
    javascript: {
      name: 'javascript',
      context: JavascriptContext
    },
    html: {
      name: 'text/html',
      context: HTMLContext
    }
  };

  /*
  Codeblock ---------------------------------------------------------------------
  */


  Codeblock = (function(_super) {

    __extends(Codeblock, _super);

    function Codeblock(node, language_name, context, dependencies, cb, cbThis) {
      var d, _i, _len,
        _this = this;
      this.language_name = language_name;
      this.context = context;
      Codeblock.__super__.constructor.call(this);
      $(node).addClass(RUNNING_CLASS);
      this.depended_on_by = [];
      this.dependencies = [];
      this.current_evaluation_contexts = new Set();
      if (dependencies != null) {
        for (_i = 0, _len = dependencies.length; _i < _len; _i++) {
          d = dependencies[_i];
          this.addDep(d);
        }
      }
      this.editor = new Editor(node, this.language_name, cb, cbThis);
      this.editor.addChangeCallback(function() {
        return _this["eval"]();
      });
    }

    Codeblock.prototype["eval"] = function(special_context) {
      var c, ctx, d, res, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
      ctx = special_context || this.context;
      logStart('Codeblock Evaluation', this.toString(), ctx.toString());
      if (this.current_evaluation_contexts.contains(ctx)) {
        log('eval aborted: already evaled in this context');
        logEnd();
        return;
      }
      this.current_evaluation_contexts.add(ctx);
      if (this.dependencies != null) {
        _ref = this.dependencies;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          d = _ref[_i];
          d["eval"](ctx);
        }
      }
      res = ctx["eval"](this.getCode());
      if (this.depended_on_by != null) {
        _ref1 = this.depended_on_by;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          d = _ref1[_j];
          d["eval"]();
        }
      }
      this.current_evaluation_contexts.remove(ctx);
      if (this.callbacks != null) {
        _ref2 = this.callbacks;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          c = _ref2[_k];
          c[0].call((_ref3 = c[1]) != null ? _ref3 : null, res, this);
        }
      }
      logEnd();
      return res;
    };

    Codeblock.prototype.getCode = function() {
      return this.editor.getCode();
    };

    Codeblock.prototype.addCallback = function(cbk, thisObject) {
      if (this.callbacks != null) {
        return this.callbacks.push([cbk, thisObject]);
      } else {
        return this.callbacks = [[cbk, thisObject]];
      }
    };

    Codeblock.prototype.addDep = function(ed) {
      log('adding dep', ed);
      this.dependencies.push(ed);
      return ed.depended_on_by.push(this);
    };

    return Codeblock;

  })(Id);

  /*
  DOM UI Widgets-----------------------------------------------------------------
  */


  Editor = (function() {

    function Editor(node, lang_name, cb, cbThis) {
      var $node, code, ed,
        _this = this;
      this.changeCallbacks = [];
      $node = $(node);
      log('Editor init', node, lang_name);
      code = $node.get(0).innerHTML;
      code = code.replace(/^\n/, "").replace(/\n*$/, "").replace(/[ \t]*\n/g, "\n").replace(/\s*$/, "");
      $node.empty();
      ed = CodeMirror($node[0], {
        value: code,
        mode: lang_name,
        onBlur: function() {
          var c, _i, _len, _ref, _results;
          log('Editor.onBlur', _this);
          _ref = _this.changeCallbacks;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            c = _ref[_i];
            _results.push(c(ed.getValue(), _this));
          }
          return _results;
        }
      });
      ed.setOption('cursorBlinkRate', 460);
      ed.setOption('cursorHeight', 1.2);
      ed.setOption('lineWrapping', true);
      if (cb && !$node.hasClass('hide')) {
        cb.call(cbThis, ed);
      }
      this.editor = ed;
    }

    Editor.prototype.getCode = function() {
      var startsWithVar, val;
      val = this.editor.getValue();
      startsWithVar = /^\s*var\s+/;
      if (val.indexOf('emptyCan') === -1) {
        val = val.replace(startsWithVar, '');
      }
      return val.replace(/\s*\/\/((?!\n).)*\n/g, ';');
    };

    Editor.prototype.addChangeCallback = function(fn) {
      return this.changeCallbacks.push(fn);
    };

    return Editor;

  })();

  OutputWindow = (function(_super) {

    __extends(OutputWindow, _super);

    function OutputWindow(node, codeblock) {
      this.codeblock = codeblock;
      log('OutputWindow init', node, this.codeblock);
      this.node = $(node).addClass("" + RUNNING_CLASS + " output");
      this.codeblock.addCallback(this.updateCallback, this);
    }

    OutputWindow.prototype.updateCallback = function(result) {
      return this.node.trigger('evaluate', [result, this.codeblock]);
    };

    return OutputWindow;

  })(Id);

  /*
  Declarative scanner -------------------------------------------------------
  
  turns HTML5 like the following into LiveCode objects and widgets.
  Manages contexts, named editors, and outputs.
  
  See the documentation for information on the HTML5 API
  
    <div class="living-script javascript no-output" id="derp-1">
      log('derp')
    </div>
  
    <div class="living-script javascript" data-depends-on="derp-1">
      log('derp')
    </div>
  
    <div class="living-script javascript" data-context="new">
      log('derp')
    </div>
  */


  Scanner = (function() {

    function Scanner() {
      var lang, name, _ref;
      this.languageControllers = {};
      _ref = exports.languages;
      for (name in _ref) {
        lang = _ref[name];
        this.languageControllers[name] = new LanguageController(lang);
      }
    }

    Scanner.prototype.allBlocks = function() {
      var controller, res, _, _ref;
      res = [];
      _ref = this.languageControllers;
      for (_ in _ref) {
        controller = _ref[_];
        res = res.concat(controller.blocks);
      }
      return res;
    };

    Scanner.prototype.getNamedBlock = function(name) {
      var candidate, controller, _, _ref;
      _ref = this.languageControllers;
      for (_ in _ref) {
        controller = _ref[_];
        candidate = controller.namedBlocks.get(name);
        if (candidate != null) {
          return candidate;
        }
      }
      return void 0;
    };

    Scanner.prototype.scan = function(node, cb, cbThis) {
      var block_nodes, output_nodes,
        _this = this;
      block_nodes = $(node).find("." + LIB_CLASS + ":not(." + RUNNING_CLASS + ", .output)");
      block_nodes.each(function(_, n) {
        var $n, controller, lang, _ref;
        $n = $(n);
        _ref = _this.languageControllers;
        for (lang in _ref) {
          controller = _ref[lang];
          if ($n.hasClass(lang)) {
            return controller.buildBlock(n, cb, cbThis);
          }
        }
      });
      output_nodes = $(node).find("." + LIB_CLASS + ".output:not(." + RUNNING_CLASS + ")");
      output_nodes.each(function(_, n) {
        return _this.buildOutput(n);
      });
      return this;
    };

    Scanner.prototype.buildOutput = function(node) {
      var $node, ed, output, output_for;
      $node = $(node);
      log(node, 'building output');
      output_for = $node.data('for');
      if (!output_for) {
        throw Error("Script outputs must display results for a named editor");
      }
      ed = this.getNamedBlock(output_for);
      if (!ed) {
        throw Error("No living-script named " + output_for + " found");
      }
      return output = new OutputWindow(node, ed);
    };

    return Scanner;

  })();

  /*
  Language Controller -----------------------------------------------------------
  
  A meta-context that manages named blocks, named contexts, and finding dependencies
  using the HTML5 API. If you want to use LanguageController features, you should
  use the HTML5 API right now -- There's no reason to use the LanguageController
  outside of a scanning situation. You don't need one for dependencies and contexts to work.
  You'll just have to track and store contexts yourself.
  
  In charge of creating codeblocks and contexts from DOM nodes.
  Tracks codeblock names
  Tracks context names
  see LanguageController.blocks for a list of all blocks scanned in this language
  
  One controller per language in a Scanner.
  */


  LanguageController = (function() {

    function LanguageController(language) {
      this.language = language;
      this.Context = this.language.context;
      this.defaultContext = new this.Context();
      this.contexts = new TwoWayDict();
      this.namedBlocks = new TwoWayDict();
      this.blocks = [];
    }

    LanguageController.prototype.buildBlock = function(node, cb, cbThis) {
      var $node, block, ctx, ctx_name, deps, id, out, out_node,
        _this = this;
      $node = $(node);
      log(node, 'building editor');
      ctx_name = $node.data('context');
      if (ctx_name) {
        if (this.contexts.contains(ctx_name)) {
          ctx = this.contexts.get(ctx_name);
        } else {
          ctx = new this.Context();
          this.contexts.assoc(ctx_name, ctx);
        }
      } else {
        ctx = this.defaultContext;
      }
      deps = $node.data('dependsOn');
      if (deps) {
        log('with dependency', deps);
        deps = deps.split(' ').map(function(d) {
          if (_this.namedBlocks.contains(d)) {
            return _this.namedBlocks.get(d);
          } else {
            throw new Error("Named depencency " + d + " undefined for language " + _this.language.name);
          }
        });
      }
      log('deps', deps);
      block = new Codeblock(node, this.language.name, ctx, deps, cb, cbThis);
      this.blocks.push(block);
      if (!$node.hasClass('no-output')) {
        out_node = $create('div').insertAfter(node);
        out = new OutputWindow($get(out_node), block);
      }
      id = $node.attr('id');
      if (id) {
        log('saved named editor', id, block);
        return this.namedBlocks.assoc(id, block);
      }
    };

    return LanguageController;

  })();

  exports.scan = function(node, cb, cbThis) {
    return (new Scanner()).scan(node, cb, cbThis);
  };

  exports.Context = Context;

  exports.Codeblock = Codeblock;

  exports.Editor = Editor;

  exports.OutputWindpw = OutputWindow;

  exports.Scanner = Scanner;

  exports.LanguageController = LanguageController;

  window.LiveCode = exports;

  return exports;

}).call(this);
